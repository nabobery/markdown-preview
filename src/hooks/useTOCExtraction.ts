import { useEffect, useCallback, useRef } from "react";
import { useTOC } from "../contexts/TOCContext";
import GithubSlugger from "github-slugger";
import type { TOCHeading } from "../types";

/**
 * Enhanced TOC extraction that perfectly matches rehype-slug behavior
 * Uses GitHub Slugger algorithm and extracts from rendered DOM for accuracy
 */
export const useTOCExtraction = (markdownContent: string) => {
  const { setHeadings } = useTOC();
  const extractionTimeoutRef = useRef<number | null>(null);
  const lastContentRef = useRef<string>("");

  // Extract headings from rendered DOM (most accurate method)
  const extractFromDOM = useCallback(() => {
    try {
      // Find the preview container
      const previewContainer = document.querySelector(
        '[data-testid="preview-content"]'
      );
      if (!previewContainer) {
        console.warn("Preview container not found");
        return [];
      }

      // Find all heading elements with IDs (generated by rehype-slug)
      const headingElements = previewContainer.querySelectorAll(
        "h1[id], h2[id], h3[id], h4[id], h5[id], h6[id]"
      );

      const headings: TOCHeading[] = [];

      headingElements.forEach((element) => {
        const tagName = element.tagName.toLowerCase();
        const level = parseInt(tagName.charAt(1), 10); // Extract number from h1, h2, etc.
        const id = element.id;

        // Get clean text content (remove emoji links and extra whitespace)
        let text = element.textContent || "";

        // Remove the emoji link added by rehype-autolink-headings
        text = text.replace(/^ðŸ”—\s*/, "").trim();

        if (text && id && level >= 1 && level <= 6) {
          headings.push({
            id,
            text,
            level,
            slug: id, // Use the actual DOM ID as slug
          });
        }
      });

      return headings;
    } catch (error) {
      console.warn("Failed to extract headings from DOM:", error);
      return [];
    }
  }, []);

  // Fallback: Extract from markdown content using GitHub Slugger
  const extractFromMarkdown = useCallback((content: string) => {
    try {
      const slugger = new GithubSlugger();

      // Extract headings from markdown content
      const headingRegex = /^(#{1,6})\s+(.+)$/gm;
      const headings: TOCHeading[] = [];
      let match;

      while ((match = headingRegex.exec(content)) !== null) {
        const level = match[1].length; // Number of # characters
        const text = match[2].trim();

        // Remove markdown formatting from text for clean display
        const cleanText = text
          .replace(/\*\*(.*?)\*\*/g, "$1") // Remove bold
          .replace(/\*(.*?)\*/g, "$1") // Remove italic
          .replace(/`(.*?)`/g, "$1") // Remove inline code
          .replace(/\[(.*?)\]\(.*?\)/g, "$1") // Remove links, keep text
          .trim();

        // Generate slug using GitHub Slugger (same as rehype-slug)
        const slug = slugger.slug(cleanText);

        if (cleanText && slug && level >= 1 && level <= 6) {
          headings.push({
            id: slug,
            text: cleanText,
            level,
            slug,
          });
        }
      }

      return headings;
    } catch (error) {
      console.warn("Failed to extract headings from markdown:", error);
      return [];
    }
  }, []);

  // Main extraction function with intelligent fallback
  const extractHeadings = useCallback(() => {
    if (!markdownContent.trim()) {
      setHeadings([]);
      return;
    }

    // Try DOM extraction first (most accurate)
    let headings = extractFromDOM();

    // If DOM extraction didn't work or returned empty, fall back to markdown parsing
    if (headings.length === 0) {
      headings = extractFromMarkdown(markdownContent);
    }

    // Validate and deduplicate headings
    const validHeadings = headings
      .filter(
        (heading) =>
          heading.id && heading.text && heading.level >= 1 && heading.level <= 6
      )
      .reduce((acc, heading) => {
        // Deduplicate by ID
        if (!acc.find((h) => h.id === heading.id)) {
          acc.push(heading);
        }
        return acc;
      }, [] as TOCHeading[]);

    setHeadings(validHeadings);

    // Debug logging in development
    if (process.env.NODE_ENV === "development") {
      console.log("TOC Extraction Results:", {
        method: headings.length > 0 ? "DOM" : "Markdown",
        count: validHeadings.length,
        headings: validHeadings,
      });
    }
  }, [markdownContent, extractFromDOM, extractFromMarkdown, setHeadings]);

  // Effect to handle content changes with debouncing
  useEffect(() => {
    // Clear any pending extraction
    if (extractionTimeoutRef.current) {
      clearTimeout(extractionTimeoutRef.current);
    }

    // Skip if content hasn't actually changed
    if (lastContentRef.current === markdownContent) {
      return;
    }
    lastContentRef.current = markdownContent;

    // Immediate extraction for empty content
    if (!markdownContent.trim()) {
      setHeadings([]);
      return;
    }

    // Debounced extraction for content changes
    extractionTimeoutRef.current = window.setTimeout(() => {
      extractHeadings();
    }, 100); // Small delay to allow DOM to update

    return () => {
      if (extractionTimeoutRef.current) {
        clearTimeout(extractionTimeoutRef.current);
      }
    };
  }, [markdownContent, extractHeadings, setHeadings]);

  // Effect to re-extract when DOM changes (e.g., after markdown renders)
  useEffect(() => {
    // Set up a mutation observer to watch for heading changes in the preview
    const previewContainer = document.querySelector(
      '[data-testid="preview-content"]'
    );

    if (!previewContainer) {
      return;
    }

    const observer = new MutationObserver((mutations) => {
      // Check if any heading elements were added/modified
      const hasHeadingChanges = mutations.some((mutation) => {
        const addedNodes = Array.from(mutation.addedNodes);
        const modifiedNodes = [mutation.target];

        return [...addedNodes, ...modifiedNodes].some((node) => {
          if (node.nodeType === Node.ELEMENT_NODE) {
            const element = node as Element;
            return (
              element.matches("h1, h2, h3, h4, h5, h6") ||
              element.querySelector("h1, h2, h3, h4, h5, h6")
            );
          }
          return false;
        });
      });

      if (hasHeadingChanges) {
        // Re-extract headings after DOM changes
        if (extractionTimeoutRef.current) {
          clearTimeout(extractionTimeoutRef.current);
        }
        extractionTimeoutRef.current = window.setTimeout(() => {
          extractHeadings();
        }, 150); // Slightly longer delay for DOM mutations
      }
    });

    observer.observe(previewContainer, {
      childList: true,
      subtree: true,
      attributes: true,
      attributeFilter: ["id"], // Watch for ID changes on headings
    });

    return () => {
      observer.disconnect();
      if (extractionTimeoutRef.current) {
        clearTimeout(extractionTimeoutRef.current);
      }
    };
  }, [extractHeadings]);
};
